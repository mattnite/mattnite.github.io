<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mattnite&#39;s blog</title>
    <link>https://mattnite.github.io/</link>
    <description>Recent content on mattnite&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Matthew Knight</copyright>
    <lastBuildDate>Tue, 27 Jul 2021 23:52:05 -0800</lastBuildDate><atom:link href="https://mattnite.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>https://mattnite.github.io/about/</link>
      <pubDate>Sat, 25 Dec 2021 23:49:10 -0800</pubDate>
      
      <guid>https://mattnite.github.io/about/</guid>
      <description>Low-level programmer, I work with C/C++ in my day job, but majority of my open-source work is in Zig. If you&amp;rsquo;re familiar with what I do and would like to support it, here is my sponsors page, thanks!
 </description>
    </item>
    
    <item>
      <title>@import and Packages</title>
      <link>https://mattnite.github.io/posts/import-and-packages/</link>
      <pubDate>Tue, 27 Jul 2021 23:52:05 -0800</pubDate>
      
      <guid>https://mattnite.github.io/posts/import-and-packages/</guid>
      <description>@import() The import builtin is how you use code from outside your file. A string literal is given as an argument and this is either a relative path to another file or an arbitrary string configured to represent a package. An important detail here is that the path case cannot reach above the root file, so let&amp;rsquo;s say we have the following filesystem:
map.zig src/ main.zig bar.zig parser/ http.zig foo/ blarg.</description>
    </item>
    
    <item>
      <title>Template Metaprogramming For Register Abstraction</title>
      <link>https://mattnite.github.io/posts/register-abstraction/</link>
      <pubDate>Tue, 03 Sep 2019 15:26:34 +0000</pubDate>
      
      <guid>https://mattnite.github.io/posts/register-abstraction/</guid>
      <description>It&amp;rsquo;s been a while since my last post and I&amp;rsquo;ve got a lot of cool bare metal stuff to show you guys. This one is going to go over different methods of manipulating Special Function Registers (SFRs), and to end it I&amp;rsquo;ll be covering a method that encodes all the SFRs of a microcontroller into a C++ type which will allow us to use template metaprogramming!. Let&amp;rsquo;s get this damn thing on the road:</description>
    </item>
    
    <item>
      <title>Bare Minimum STM32 Toolchain Setup</title>
      <link>https://mattnite.github.io/posts/bare-minimum-stm32-toolchain-setup/</link>
      <pubDate>Fri, 24 May 2019 21:16:51 +0000</pubDate>
      
      <guid>https://mattnite.github.io/posts/bare-minimum-stm32-toolchain-setup/</guid>
      <description>The first thing I’m going to cover here is setting up a bare minimum environment that cross-compiles for a microcontroller (MCU). You can probably do this for Windows, especially since I’ll be using cmake, but I’ll just be using Linux for the development environment. Most of this post is reiterating Michael Caisse’s talk at C++Now 20181, and applying it to a NUCLEO-L073RZ development board by STMicro.
I mostly picked this MCU because it’s made for low power applications which I want to play around with in the future, it’s got a built-in DAC (nice for signal processing), and the GPIO ports can be toggled faster per instruction than other architectures in the STM32 line.</description>
    </item>
    
  </channel>
</rss>
